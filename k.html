<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaleidoscope App</title>
    <!-- Use Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use the Inter font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        canvas {
            touch-action: none; /* Prevents default touch gestures on the canvas */
        }
    </style>
    <!-- CDN for gif.js -->
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Main Container -->
    <div class="bg-gray-800 p-8 rounded-2xl shadow-lg w-full max-w-4xl flex flex-col items-center space-y-6">
        <h1 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-600 mb-4">Kaleidoscope</h1>

        <!-- Control Buttons -->
        <div class="flex flex-col sm:flex-row gap-4 w-full justify-center mb-6">
            <!-- Button to open file input -->
            <button id="uploadBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 transform hover:scale-105 shadow-md">
                Upload Image
            </button>

            <!-- Button to toggle webcam -->
            <button id="webcamBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 transform hover:scale-105 shadow-md">
                Start Webcam
            </button>

            <!-- Save Image button -->
            <button id="saveBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 transform hover:scale-105 shadow-md">
                Save Image
            </button>

            <!-- New: Create GIF button -->
            <button id="createGifBtn" class="bg-orange-600 hover:bg-orange-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 transform hover:scale-105 shadow-md">
                Create GIF
            </button>
            <input type="file" id="imageInput" accept="image/*, .webp" class="hidden">
        </div>

        <!-- New: URL and Controls Section -->
        <div class="w-full flex flex-col items-center space-y-4">
            <!-- URL Input and Button -->
            <div class="w-full flex flex-col sm:flex-row gap-2">
                <input type="url" id="urlInput" placeholder="Enter image URL" class="w-full p-3 rounded-lg bg-gray-700 text-gray-200 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
                <button id="loadUrlBtn" class="bg-emerald-600 hover:bg-emerald-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 transform hover:scale-105 shadow-md sm:w-auto">
                    Load URL
                </button>
            </div>
            
            <!-- Sliders for Slices, Zoom, and Rotation -->
            <div class="w-full grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
                <!-- Slices Slider -->
                <div class="flex flex-col items-center p-3 rounded-xl bg-gray-700">
                    <label for="slicesSlider" class="text-sm font-medium mb-2">Slices: <span id="slicesValue">8</span></label>
                    <input type="range" id="slicesSlider" min="2" max="32" value="8" step="1" class="w-full appearance-none h-2 bg-gray-500 rounded-lg cursor-pointer accent-blue-500">
                </div>

                <!-- Zoom Slider -->
                <div class="flex flex-col items-center p-3 rounded-xl bg-gray-700">
                    <label for="zoomSlider" class="text-sm font-medium mb-2">Zoom: <span id="zoomValue">1.0</span></label>
                    <input type="range" id="zoomSlider" min="0.1" max="3" value="1.0" step="0.01" class="w-full appearance-none h-2 bg-gray-500 rounded-lg cursor-pointer accent-purple-500">
                </div>
                
                <!-- Rotation Slider -->
                <div class="flex flex-col items-center p-3 rounded-xl bg-gray-700">
                    <label for="rotationSlider" class="text-sm font-medium mb-2">Rotation: <span id="rotationValue">0°</span></label>
                    <input type="range" id="rotationSlider" min="0" max="360" value="0" step="1" class="w-full appearance-none h-2 bg-gray-500 rounded-lg cursor-pointer accent-fuchsia-500">
                </div>

                <!-- X Position Slider -->
                <div class="flex flex-col items-center p-3 rounded-xl bg-gray-700">
                    <label for="xPosSlider" class="text-sm font-medium mb-2">X Position: <span id="xPosValue">0</span></label>
                    <input type="range" id="xPosSlider" min="-200" max="200" value="0" step="1" class="w-full appearance-none h-2 bg-gray-500 rounded-lg cursor-pointer accent-cyan-500">
                </div>
                
                <!-- Y Position Slider -->
                <div class="flex flex-col items-center p-3 rounded-xl bg-gray-700">
                    <label for="yPosSlider" class="text-sm font-medium mb-2">Y Position: <span id="yPosValue">0</span></label>
                    <input type="range" id="yPosSlider" min="-200" max="200" value="0" step="1" class="w-full appearance-none h-2 bg-gray-500 rounded-lg cursor-pointer accent-cyan-500">
                </div>
            </div>
        </div>

        <!-- Canvas for Kaleidoscope effect -->
        <div class="relative w-full aspect-square max-w-xl mt-6">
            <canvas id="kaleidoscopeCanvas" class="bg-gray-700 rounded-xl shadow-inner border border-gray-600"></canvas>
            <!-- Loading and message overlay -->
            <div id="messageOverlay" class="absolute inset-0 flex flex-col items-center justify-center p-4 text-center rounded-xl bg-gray-900/70 backdrop-blur-sm transition-opacity duration-300">
                <p id="messageText" class="text-gray-300 text-lg font-medium hidden">Loading...</p>
                <!-- New: Progress bar container for GIF generation -->
                <div id="progressBarContainer" class="w-2/3 bg-gray-500 h-2 rounded-full mt-4 hidden">
                    <div id="progressBar" class="bg-orange-400 h-2 rounded-full transition-all duration-300 ease-linear" style="width: 0%;"></div>
                </div>
                <!-- New: GIF container to display the animated GIF -->
                <div id="gifContainer" class="flex flex-col items-center mt-4 hidden">
                    <img id="gifDisplay" class="rounded-xl shadow-lg border-4 border-gray-700 max-h-96 w-full">
                    <div class="flex gap-4 mt-4">
                        <button id="downloadGifBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 transform hover:scale-105 shadow-md">
                            Download GIF
                        </button>
                        <button id="hideGifBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 transform hover:scale-105 shadow-md">
                            Hide GIF
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript for the Kaleidoscope logic -->
    <script>
        // Get necessary DOM elements
        const imageInput = document.getElementById('imageInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const webcamBtn = document.getElementById('webcamBtn');
        const saveBtn = document.getElementById('saveBtn'); 
        const createGifBtn = document.getElementById('createGifBtn');
        const urlInput = document.getElementById('urlInput');
        const loadUrlBtn = document.getElementById('loadUrlBtn');
        const slicesSlider = document.getElementById('slicesSlider');
        const slicesValueSpan = document.getElementById('slicesValue');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValueSpan = document.getElementById('zoomValue');
        const rotationSlider = document.getElementById('rotationSlider');
        const rotationValueSpan = document.getElementById('rotationValue');
        const xPosSlider = document.getElementById('xPosSlider');
        const xPosValueSpan = document.getElementById('xPosSlider');
        const yPosSlider = document.getElementById('yPosSlider');
        const yPosValueSpan = document.getElementById('yPosSlider');
        const canvas = document.getElementById('kaleidoscopeCanvas');
        const messageOverlay = document.getElementById('messageOverlay');
        const messageText = document.getElementById('messageText');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBar = document.getElementById('progressBar');
        const gifContainer = document.getElementById('gifContainer');
        const gifDisplay = document.getElementById('gifDisplay');
        const downloadGifBtn = document.getElementById('downloadGifBtn');
        const hideGifBtn = document.getElementById('hideGifBtn');

        // State variables
        let sourceImage = new Image();
        let video = null;
        let isWebcamActive = false;
        let isImageLoaded = false;
        let isGeneratingGif = false;
        let isGLActive = false;
        
        // GL variables
        let gl;
        let program;
        let texture;
        let verticesBuffer;
        let slicesLoc, zoomLoc, rotationLoc, offsetXLoc, offsetYLoc, resolutionLoc, texSizeLoc;

        // GLSL Vertex Shader Source
        const vsSource = `
            attribute vec2 a_position;

            void main() {
                gl_Position = vec4(a_position, 0, 1);
            }
        `;

        // GLSL Fragment Shader Source
        const fsSource = `
            precision mediump float;

            uniform sampler2D u_image;
            uniform float u_slices;
            uniform float u_zoom;
            uniform float u_rotation;
            uniform vec2 u_offset;
            uniform vec2 u_resolution;
            uniform vec2 u_texSize;

            void main() {
                // Normalize screen coordinates to the range [-1, 1]
                vec2 center = u_resolution * 0.5;
                vec2 pos = gl_FragCoord.xy - center;

                // Calculate the polar coordinates from the pixel position
                float radius = length(pos);
                float angle = atan(pos.y, pos.x);

                // Adjust angle to be in the range [0, 2 * PI]
                if (angle < 0.0) {
                    angle += 2.0 * 3.14159265359;
                }

                // Calculate the slice and new angle based on the number of slices
                float sliceAngle = 2.0 * 3.14159265359 / u_slices;
                float slice = floor(angle / sliceAngle);
                float newAngle = mod(angle, sliceAngle);

                // Mirror every other slice
                if (mod(slice, 2.0) == 1.0) {
                    newAngle = sliceAngle - newAngle;
                }

                // Convert back to cartesian coordinates
                float newX = radius * cos(newAngle);
                float newY = radius * sin(newAngle);

                // Apply continuous rotation, zoom, and offset
                float rotRadians = u_rotation * 3.14159265359 / 180.0;
                float rotatedX = newX * cos(rotRadians) - newY * sin(rotRadians);
                float rotatedY = newX * sin(rotRadians) + newY * cos(rotRadians);
                
                rotatedX *= (1.0 / u_zoom);
                rotatedY *= (1.0 / u_zoom);

                // Map coordinates to texture space [0, 1]
                vec2 texCoord = vec2(rotatedX + u_texSize.x / 2.0, rotatedY + u_texSize.y / 2.0) + u_offset;
                texCoord.x /= u_texSize.x;
                texCoord.y /= u_texSize.y;

                // Get the color from the texture
                gl_FragColor = texture2D(u_image, texCoord);
            }
        `;

        // Function to compile a shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Function to initialize the WebGL context and shaders
        function initGL() {
            gl = canvas.getContext('webgl');
            if (!gl) {
                console.error('WebGL not supported. Falling back to 2D.');
                updateOverlay('initial', 'Your browser does not support WebGL. Performance may be degraded.');
                return false;
            }

            // Create and compile shaders
            const vertexShader = compileShader(vsSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(fsSource, gl.FRAGMENT_SHADER);

            // Create and link the shader program
            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error: ' + gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return false;
            }
            gl.useProgram(program);

            // Create a buffer to hold a quad that covers the screen
            verticesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

            // Set up vertex attributes
            const positionLoc = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

            // Get uniform locations
            slicesLoc = gl.getUniformLocation(program, 'u_slices');
            zoomLoc = gl.getUniformLocation(program, 'u_zoom');
            rotationLoc = gl.getUniformLocation(program, 'u_rotation');
            offsetXLoc = gl.getUniformLocation(program, 'u_offset');
            resolutionLoc = gl.getUniformLocation(program, 'u_resolution');
            texSizeLoc = gl.getUniformLocation(program, 'u_texSize');

            // Create texture
            texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

            isGLActive = true;
            return true;
        }

        // Function to draw the kaleidoscope effect using WebGL
        function drawKaleidoscope() {
            if (!isGLActive) return;

            // Set canvas size dynamically
            const canvasSize = Math.min(window.innerWidth - 32, 640);
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            gl.viewport(0, 0, canvas.width, canvas.height);

            let source = isWebcamActive ? video : sourceImage;
            if (!source || (!isWebcamActive && !isImageLoaded)) {
                gl.clearColor(0.2, 0.2, 0.2, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                return;
            }
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);

            gl.uniform1f(slicesLoc, slicesSlider.value);
            gl.uniform1f(zoomLoc, zoomSlider.value);
            gl.uniform1f(rotationLoc, rotationSlider.value);
            gl.uniform2f(offsetXLoc, xPosSlider.value, yPosSlider.value);
            gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
            gl.uniform2f(texSizeLoc, source.videoWidth || source.width, source.videoHeight || source.height);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        const saveKaleidoscopeImage = () => {
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = 'kaleidoscope.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };

        const createAnimatedGif = async () => {
            if (!isImageLoaded && !isWebcamActive) {
                updateOverlay('initial', 'Please upload an image or start the webcam first.');
                return;
            }
            
            isGeneratingGif = true;
            createGifBtn.disabled = true;
            uploadBtn.disabled = true;
            webcamBtn.disabled = true;
            saveBtn.disabled = true;
            
            updateOverlay('loading', 'Generating GIF...');
            
            const workerScriptUrl = 'https://unpkg.com/gif.js@0.2.0/dist/gif.worker.js';
            let gif;

            try {
                const response = await fetch(workerScriptUrl);
                const blob = await response.blob();
                const localWorkerScriptUrl = URL.createObjectURL(blob);

                gif = new GIF({
                    workers: 2,
                    quality: 10,
                    width: canvas.width,
                    height: canvas.height,
                    workerScript: localWorkerScriptUrl
                });

                gif.on('progress', (p) => {
                    const percent = Math.floor(p * 100);
                    messageText.textContent = `Generating GIF: ${percent}%`;
                    progressBar.style.width = `${percent}%`;
                });

                gif.on('finished', (blob) => {
                    const url = URL.createObjectURL(blob);
                    
                    gifDisplay.src = url;
                    
                    downloadGifBtn.onclick = () => {
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = 'kaleidoscope-animation.gif';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    };

                    URL.revokeObjectURL(gif.options.workerScript);

                    updateOverlay('finished');
                    isGeneratingGif = false;
                    createGifBtn.disabled = false;
                    uploadBtn.disabled = false;
                    webcamBtn.disabled = false;
                    saveBtn.disabled = false;
                });
                
                gif.on('error', (err) => {
                    console.error('GIF generation error:', err);
                    updateOverlay('error', `Error creating GIF. Details: ${err.message || 'Unknown error'}`);
                    
                    isGeneratingGif = false;
                    createGifBtn.disabled = false;
                    uploadBtn.disabled = false;
                    webcamBtn.disabled = false;
                    saveBtn.disabled = false;
                });

                const originalRotation = parseFloat(rotationSlider.value);
                const numFrames = 60;
                const rotationStep = 360 / numFrames;

                const pixels = new Uint8Array(canvas.width * canvas.height * 4);
                
                for (let i = 0; i < numFrames; i++) {
                    rotationSlider.value = (originalRotation + i * rotationStep) % 360;
                    drawKaleidoscope();

                    gl.readPixels(0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

                    const tempCanvas2D = document.createElement('canvas');
                    const tempCtx2D = tempCanvas2D.getContext('2d');
                    tempCanvas2D.width = canvas.width;
                    tempCanvas2D.height = canvas.height;
                    const imageData = tempCtx2D.createImageData(canvas.width, canvas.height);
                    
                    const rowSize = canvas.width * 4;
                    for(let y = 0; y < canvas.height; y++) {
                        const glY = canvas.height - 1 - y;
                        const srcStartIndex = glY * rowSize;
                        const destStartIndex = y * rowSize;
                        imageData.data.set(pixels.subarray(srcStartIndex, srcStartIndex + rowSize), destStartIndex);
                    }

                    tempCtx2D.putImageData(imageData, 0, 0);
                    gif.addFrame(tempCanvas2D, { delay: 75, copy: true });
                }
                
                rotationSlider.value = originalRotation;
                rotationValueSpan.textContent = `${Math.floor(originalRotation)}°`;

                gif.render();

            } catch (err) {
                console.error("Failed to start GIF creation:", err);
                updateOverlay('error', `An unexpected error occurred: ${err.message || 'Unknown error'}`);
                
                isGeneratingGif = false;
                createGifBtn.disabled = false;
                uploadBtn.disabled = false;
                webcamBtn.disabled = false;
                saveBtn.disabled = false;
            }
        };

        const stopWebcam = () => {
            if (isWebcamActive) {
                const stream = video.srcObject;
                stream.getTracks().forEach(track => track.stop());
                video = null;
                isWebcamActive = false;
                webcamBtn.textContent = 'Start Webcam';
            }
        };

        /**
         * Centralized function to update the overlay's state.
         * @param {'initial'|'loading'|'finished'|'error'} state The new state to display.
         * @param {string} [message] The message text to display. Only for 'initial', 'loading', and 'error' states.
         */
        function updateOverlay(state, message = '') {
            // Hide everything first to ensure a clean state
            messageOverlay.classList.add('hidden');
            messageText.classList.add('hidden');
            progressBarContainer.classList.add('hidden');
            gifContainer.classList.add('hidden');

            if (state === 'initial') {
                messageOverlay.classList.remove('hidden');
                messageText.textContent = message;
                messageText.classList.remove('hidden');
            } else if (state === 'loading') {
                messageOverlay.classList.remove('hidden');
                messageText.textContent = message;
                messageText.classList.remove('hidden');
                progressBarContainer.classList.remove('hidden');
            } else if (state === 'finished') {
                messageOverlay.classList.remove('hidden');
                gifContainer.classList.remove('hidden');
            } else if (state === 'error') {
                messageOverlay.classList.remove('hidden');
                messageText.textContent = message;
                messageText.classList.remove('hidden');
            }
        }
        
        // Add event listeners
        uploadBtn.addEventListener('click', () => imageInput.click());

        imageInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                stopWebcam();
                updateOverlay('loading', 'Loading image...');
                const reader = new FileReader();
                reader.onload = (e) => {
                    sourceImage.crossOrigin = 'anonymous';
                    sourceImage.onload = () => {
                        isImageLoaded = true;
                        messageOverlay.classList.add('hidden');
                        drawKaleidoscope();
                    };
                    sourceImage.onerror = () => {
                        updateOverlay('error', 'Error loading image. Please try a different file.');
                        isImageLoaded = false;
                    }
                    sourceImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        
        loadUrlBtn.addEventListener('click', async () => {
            const url = urlInput.value;
            if (!url) {
                updateOverlay('initial', 'Please enter a valid image URL.');
                return;
            }

            stopWebcam();
            updateOverlay('loading', 'Loading image from URL...');

            try {
                // Use a CORS proxy to bypass cross-origin security restrictions
                const proxiedUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                console.log('Fetching from proxied URL:', proxiedUrl);

                // Use fetch to get the image data more robustly
                const response = await fetch(proxiedUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const blob = await response.blob();
                const objectURL = URL.createObjectURL(blob);

                sourceImage.crossOrigin = 'anonymous'; 
                sourceImage.onload = () => {
                    isImageLoaded = true;
                    messageOverlay.classList.add('hidden');
                    drawKaleidoscope();
                    // Clean up the object URL after use to free up memory
                    URL.revokeObjectURL(objectURL);
                };
                sourceImage.onerror = () => {
                    updateOverlay('error', 'Error loading image from URL. Check the URL and try again.');
                    isImageLoaded = false;
                    URL.revokeObjectURL(objectURL); // Clean up on error as well
                };
                sourceImage.src = objectURL;
            } catch (err) {
                console.error("Error fetching image from URL:", err);
                updateOverlay('error', `Error loading image from URL. Check the URL and try again. (${err.message})`);
                isImageLoaded = false;
            }
        });

        webcamBtn.addEventListener('click', async () => {
            if (isWebcamActive) {
                stopWebcam();
                updateOverlay('initial', 'Click "Upload Image" or "Start Webcam" to begin.');
            } else {
                try {
                    updateOverlay('loading', 'Accessing webcam...');
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    video = document.createElement('video');
                    video.srcObject = stream;
                    video.play();
                    
                    isWebcamActive = true;
                    webcamBtn.textContent = 'Stop Webcam';

                    video.onloadedmetadata = () => {
                        messageOverlay.classList.add('hidden');
                        function animate() {
                            if (isWebcamActive && !isGeneratingGif) {
                                drawKaleidoscope();
                                requestAnimationFrame(animate);
                            } else if (isWebcamActive && isGeneratingGif) {
                                requestAnimationFrame(animate);
                            }
                        }
                        animate();
                    };

                } catch (err) {
                    console.error("Error accessing webcam: ", err);
                    updateOverlay('error', 'Error accessing webcam. Please check your permissions.');
                }
            }
        });
        
        saveBtn.addEventListener('click', saveKaleidoscopeImage);
        createGifBtn.addEventListener('click', createAnimatedGif);
        hideGifBtn.addEventListener('click', () => {
            // Hide the overlay and go back to the canvas
            messageOverlay.classList.add('hidden');
            // Re-draw the canvas to make sure the image is there after hiding the GIF
            drawKaleidoscope();
        });
        slicesSlider.addEventListener('input', (e) => {
            slicesValueSpan.textContent = e.target.value;
            drawKaleidoscope();
        });
        
        zoomSlider.addEventListener('input', (e) => {
            zoomValueSpan.textContent = parseFloat(e.target.value).toFixed(2);
            drawKaleidoscope();
        });
        
        rotationSlider.addEventListener('input', (e) => {
            rotationValueSpan.textContent = `${e.target.value}°`;
            drawKaleidoscope();
        });

        xPosSlider.addEventListener('input', (e) => {
            xPosValueSpan.textContent = e.target.value;
            drawKaleidoscope();
        });
        
        yPosSlider.addEventListener('input', (e) => {
            yPosValueSpan.textContent = e.target.value;
            drawKaleidoscope();
        });

        window.onload = () => {
            if (initGL()) {
                updateOverlay('initial', 'Click "Upload Image" or "Start Webcam" to begin.');
                drawKaleidoscope();
            }
        };
    </script>
</body>
</html>

